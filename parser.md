# `parser.y` Explained: A Simple Language Parser with Bison

This `parser.y` file is the grammar definition for a simple programming language, designed to be parsed using **Bison** (or Yacc), a parser generator. It defines the syntax of the language and specifies how input code should be transformed into an Abstract Syntax Tree (AST) using custom `Node` objects.

## Overview

This parser aims to recognize basic programming constructs, including:

* Variable declarations (with optional initialisation)
* Function declarations (with arguments and a block body)
* Expressions (identifiers, numbers, assignments, method calls, binary operations)
* Statements (variable declarations, function declarations, expression statements)
* Blocks of statements

The parser generates an Abstract Syntax Tree (AST) using a hierarchy of `Node` objects (presumably defined in `node.h`).

## Key Sections of `parser.y`

### 1. Preamble (`%{ ... %}`)
```
%{
#include "node.h"
NBlock *programBlock;
extern int yylex();
void yyerror(const char *s) { printf("ERROR: %s\n", s); }
%}
```

This section contains C/C++ code that is copied directly into the generated `parser.cpp` file.

* `#include "node.h"`: Includes the header file defining the AST node classes (e.g., `NBlock`, `NExpression`, `NStatement`, etc.).
* `NBlock *programBlock;`: Declares a global pointer that will hold the root of the AST for the entire program.
* `extern int yylex();`: Declares the lexical analyzer function, `yylex()`, which is typically generated by Flex (or Lex).
* `void yyerror(const char *s) { printf("ERROR: %s\n", s); }`: Defines the error handling function for Bison. When a syntax error occurs, Bison calls `yyerror`.

### 2. Union Declaration (`%union`)
```
%union {
    Node *node;
    NBlock *block;
    NExpression *expr;
    NStatement *stmt;
    NIdentifier *ident;
    NVariableDeclaration *var_decl;
    std::vector<NVariableDeclaration*> *varvec;
    std::vector<NExpression*> *exprvec;
    std::string *string;
    int token;
}
```
The `%union` declaration defines the types of values that can be associated with tokens and non-terminals. This allows Bison to pass semantic values between rules.

* `Node *node;`, `NBlock *block;`, etc.: Pointers to various AST node types.
* `std::vector<NVariableDeclaration*> *varvec;`, `std::vector<NExpression*> *exprvec;`: Pointers to vectors used for lists of variables (function arguments) and expressions (function call arguments).
* `std::string *string;`: Used for token values like identifiers and numbers (which are initially read as strings by the lexer).
* `int token;`: Used for simple token types (like operators `TPLUS`, `TEQUAL`, etc.) where the token ID itself is sufficient.

### 3. Token Declarations (`%token`)
```
%token <string> TIDENTIFIER TINTEGER TDOUBLE
%token <token> TCEQ TCNE TCLT TCLE TCGT TCGE TEQUAL
%token <token> TLPAREN TRPAREN TLBRACE TRBRACE TCOMMA TDOT
%token <token> TPLUS TMINUS TMUL TDIV
%token <token> TINT TRETURN TSEMICOLON
```
This section declares the terminal symbols (tokens) that the lexical analyzer (`yylex()`) will return. Each token is associated with a type defined in the `%union`.

* `<string>`: `TIDENTIFIER`, `TINTEGER`, `TDOUBLE` - These tokens carry string values (e.g., `"myVar"`, `"123"`, `"3.14"`).
* `<token>`: `TCEQ`, `TCNE`, `TPLUS`, `TSEMICOLON`, etc. - These tokens are simple keywords or symbols where the token type (an integer) is enough.
* `TEQUAL`: This token is used for the assignment operator (`=`).

### 4. Type Declarations for Non-terminals (`%type`)
```
%type <ident> ident
%type <expr> numeric expr 
%type <varvec> func_decl_args
%type <exprvec> call_args
%type <block> program stmts block
%type <stmt> stmt func_decl
%type <var_decl> var_decl
%type <token> comparison
%type <ident> type
```
This section associates types from the `%union` with non-terminal symbols (rules) in the grammar. This tells Bison what kind of value a particular grammar rule will produce.

* `<block>`: `program`, `stmts`, `block` - These rules construct `NBlock` objects.
* `<expr>`: `numeric`, `expr` - These rules construct `NExpression` objects.
* `<stmt>`: `stmt`, `func_decl` - These rules construct `NStatement` objects.
* `<ident>`: `ident`, `type` - These rules construct `NIdentifier` objects.
* `<var_decl>`: `var_decl` - This rule constructs an `NVariableDeclaration` object.
* `<varvec>`: `func_decl_args` - This rule constructs a `std::vector<NVariableDeclaration*>` to hold function arguments.
* `<exprvec>`: `call_args` - This rule constructs a `std::vector<NExpression*>` to hold function call arguments.
* `<token>`: `comparison` - This rule directly uses the integer value of comparison/arithmetic operators.

### 5. Operator Precedence and Associativity (`%left`, `%right`, `%nonassoc`)
```
%left TPLUS TMINUS
%left TMUL TDIV
```
These directives resolve ambiguities in the grammar by defining the precedence and associativity of operators.

* `%left TPLUS TMINUS`: `+` and `-` are left-associative and have lower precedence.
* `%left TMUL TDIV`: `*` and `/` are left-associative and have higher precedence than `+` and `-`.

### 6. Start Symbol (`%start`)
```
%start program
```
* `%start program`: Specifies that the `program` rule is the topmost rule from which parsing begins.

### 7. Grammar Rules (`%% ... %%`)
```
program : stmts { programBlock = $1; }
     ;
        
stmts : stmt { $$ = new NBlock(); $$->statements.push_back($1); }
     | stmts stmt { $1->statements.push_back($2); $$ = $1; }
     ;
stmt : var_decl TSEMICOLON
     | func_decl
     | expr TSEMICOLON { $$ = new NExpressionStatement(*$1); }
     ;
block : TLBRACE stmts TRBRACE { $$ = $2; }
     | TLBRACE TRBRACE { $$ = new NBlock(); }
     ;
var_decl : ident ident { $$ = new NVariableDeclaration(*$1, *$2); }
     | type ident TEQUAL expr { $$ = new NVariableDeclaration(*$1, *$2, $4); }
     ;
func_decl : type ident TLPAREN func_decl_args TRPAREN block 
     { $$ = new NFunctionDeclaration(*$1, *$2, *$4, *$6); delete $4; }
     ;
func_decl_args : /* empty */ { $$ = new VariableList(); }
     | var_decl { $$ = new VariableList(); $$->push_back($1); }
     | func_decl_args TCOMMA var_decl { $1->push_back($3); $$ = $1; }
     ;
ident : TIDENTIFIER { $$ = new NIdentifier(*$1); delete $1; }
     ;

numeric : TINTEGER { $$ = new NInteger(atol($1->c_str())); delete $1; }
     | TDOUBLE { $$ = new NDouble(atof($1->c_str())); delete $1; }
     ;
expr : ident TEQUAL expr { $$ = new NAssignment(*$1, *$3); }
     | ident TLPAREN call_args TRPAREN { $$ = new NMethodCall(*$1, *$3); delete $3; }
     | ident { $$ = $1; }
     | numeric
     | expr comparison expr { $$ = new NBinaryOperator(*$1, $2, *$3); }
     | TLPAREN expr TRPAREN { $$ = $2; }
     ;
call_args : /* empty */ { $$ = new ExpressionList(); }
     | expr { $$ = new ExpressionList(); $$->push_back($1); }
     | call_args TCOMMA expr { $1->push_back($3); $$ = $1; }
     ;
comparison : TCEQ | TCNE | TCLT | TCLE | TCGT | TCGE 
     | TPLUS | TMINUS | TMUL | TDIV
     ;
type : TINT { $$ = new NIdentifier("int"); }
     ;
```
This is the core of the parser, defining the syntax rules using BNF (Backus-Naur Form) notation. Each rule has an associated C/C++ action block (`{ ... }`) that is executed when the rule is successfully matched. These actions typically construct the AST nodes.

Let's look at some example rules:

* **`program : stmts { programBlock = $1; }`**:
    * A `program` consists of `stmts` (statements).
    * The action `$1` refers to the semantic value of the first symbol on the right-hand side (`stmts`). Here, it assigns the `NBlock` returned by the `stmts` rule to the global `programBlock` pointer.

* **`stmts : stmt { $$= new NBlock();$$->statements.push_back($1); }`**:
    * A `stmts` (sequence of statements) can initially be a single `stmt`.
    * `$$` refers to the semantic value of the left-hand side (`stmts`). Here, it creates a new `NBlock`, adds the single `stmt` (`$1`) to its `statements` list, and assigns this new `NBlock` to `$$`.

* **`stmts : stmts stmt { $1->statements.push_back($2); $$ = $1; }`**:
    * A `stmts` can also be an existing `stmts` followed by another `stmt`.
    * It takes the `NBlock` from the existing `stmts` (`$1`), adds the new `stmt` (`$2`) to its `statements` list, and then passes the modified `NBlock` back as `$$`. This effectively builds a list of statements.

* **`var_decl : type ident TEQUAL expr { $$ = new NVariableDeclaration(*$1, *$2, $4); }`**:
    * A `var_decl` (variable declaration) can consist of a `type`, an `ident`ifier, an assignment operator `TEQUAL`, and an `expr`ession for initialization.
    * It constructs an `NVariableDeclaration` node using the AST nodes generated by `type`, `ident`, and `expr`. The `*` dereferences the pointers to get the actual `NIdentifier` and `NExpression` objects.

* **`ident : TIDENTIFIER { $$ = new NIdentifier(*$1); delete $1; }`**:
    * An `ident`ifier rule simply takes the string value from the `TIDENTIFIER` token (`$1`), creates a new `NIdentifier` AST node, and then `delete $1` to free the dynamically allocated string.

* **`expr : expr comparison expr { $$ = new NBinaryOperator(*$1, $2, *$3); }`**:
    * An `expr`ession can be two `expr`essions separated by a `comparison` operator.
    * It creates an `NBinaryOperator` node, passing the left and right expression nodes and the integer value of the operator.

* **`call_args : /* empty */ { $$ = new ExpressionList(); }`**:
    * This rule handles the case of an empty argument list for a function call. It creates an empty `ExpressionList` (which is `std::vector<NExpression*>`).

## How it Works Together (Simplified)

1.  **Lexical Analysis (Flex/Lex):** The `tokens.l` file (not provided, but implied) reads the input source code and breaks it down into a stream of tokens (e.g., `TINT`, `TIDENTIFIER("myVar")`, `TPLUS`, `TINTEGER("10")`, `TSEMICOLON`).
2.  **Syntactic Analysis (Bison/Yacc - `parser.y`):** Bison uses the rules in `parser.y` to analyze the stream of tokens. As it matches grammar rules, the associated C/C++ actions are executed.
3.  **AST Construction:** These actions dynamically allocate `Node` objects (e.g., `NBlock`, `NFunctionDeclaration`, `NAssignment`, etc.) and link them together to form a tree structure that represents the program's logical organization.
4.  **Semantic Value Propagation:** Bison uses the `%union` and the `$` variables (`$1`, `$2`, `$$`) to pass pointers to these AST nodes up the parse tree.
5.  **Result:** Upon successful parsing, the `programBlock` global variable will point to the root of the complete AST for the parsed program, which can then be used by subsequent phases like code generation (`codegen.cpp`).

This `parser.y` provides the backbone for understanding and interpreting code written in this simple language, making it a crucial component in a compiler or interpreter pipeline.